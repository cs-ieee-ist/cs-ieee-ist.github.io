<html>
  <head>
    <!-- <link rel="stylesheet" type="text/css" href="css/template.css"></link> -->
    <link rel="stylesheet" type="text/css" href="css/IAED.css"></link>
    <!-- template.css has all default class names -->

  </head>

	<meta name="viewport" content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">

	<link rel="stylesheet" href="./css-code/application.min.4db4aeac.css" media="all">
	<link rel="stylesheet" href="./css-code/application.min.4db4aeac.css" media="all">
	<link rel="stylesheet" href="./css-code/theme.min.77312fb0.css" media="all">


  <body>
    <!--
    <div id = "pageTop">
      <div id = "projectName"><center>IAED</center></div>
      <div id = "sub1"><center>Introducao aos algoritmos e estrutura de dados</center></div>
    </div> 
    -->

    <div id = "pageBody">
      <!-- Page Content -->

      <center><h1 id = "sub1" class = "Introdução a Algoritmos e Estruturas de Dados">Heap Sort</h1></center> <!--increment the id for each topic ex sub1, sub2, sub3 etc -->



<div class="code code-line-numbers unselectable" id="line-numbers" aria-hidden="true">
  <span></span>1</span><span>2</span><span>3</span><span>4</span><span>5</span><span>6</span><span>7</span><span>8</span><span>9</span><span>10</span><span>11</span><span>12</span><span>13</span><span>14</span><span>15</span><span>16</span><span>17</span><span>18</span><span>19</span><span>20</span><span>21</span><span>22</span><span>23</span><span>24</span><span>25</span><span>26</span><span>27</span><span>28</span><span>29</span><span>30</span><span>31</span><span>32</span><span>33</span><span>34</span><span>35</span><span>36</span><span>37</span><span>38</span><span>39</span><span>40</span><span>41</span><span>42</span><span>43</span><span>44</span><span>45</span><span>46</span><span>47</span><span>48</span><span>49</span><span>50</span><span>51</span><span>52</span><span>53</span><span>54</span><span>55</span><span>56</span><span>57</span><span>58</span><span>59</span><span>60</span><span>61</span><span>62</span><span>63</span><span>64</span><span>65</span><span>66</span><span>67</span><span>68</span><span>69</span><span>70</span><span>71</span><span>72</span><span>73</span><span>74</span><span>75</span><span>76</span><span>77</span><span>78</span><span>79</span><span>80</span><span>81</span><span>82</span><span>83</span><span>84</span><span>85</span><span>86</span><span>87</span><span>88</span><span>89</span><span>90</span><span>91</span><span>92</span><span>93</span><span>94</span><span>95</span><span>96</span><span>97</span><span>98</span><span>99</span><span>100</span><span>101</span><span>102</span><span>103</span><span>104</span><span>105</span><span>106</span><span>107</span><span>108</span><span>109</span><span>110</span><span>111</span><span>112</span><span>113</span><span>114</span><span>115</span><span>116</span><span>117</span><span>118</span><span>119</span><span>120</span><span>121</span>
</div>
<div class="code" id="code"><span class="cm">/*</span>
  <span class="cm">In the first step, a heap is built out of the data. The heap is often placed</span>
  <span class="cm"> in an array with the layout of a complete binary tree.</span>
  <span class="cm">In the second step, a sorted array is created by repeatedly removing the largest</span>
  <span class="cm"> element from the heap (the root of the heap), and inserting it into the array.</span>
  <span class="cm"> The heap is updated after each removal to maintain the heap property.</span>
  <span class="cm"> Once all objects have been removed from the heap, the result is a sorted array.</span>


  <span class="cm">Worst case: O(n log n)</span>

  <span class="cm">Best case: O(n log n)</span>

<span class="cm">*/</span>



<span class="cm">/*</span>

  <span class="cm">Fixdown (indice i)</span>
  <span class="cm"> verifica se i tem um filho maior que ele</span>
  <span class="cm"> SE i tem um filho maior:</span>
  <span class="cm"> troca i com o filho_maior</span>
  <span class="cm"> Fixdown (pos_do_filho_maior)</span>

<span class="cm">*/</span>

  <span class="kt">void</span> <span class="nf">fixDown</span><span class="p">(</span><span class="n">Item</span> <span
    class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span
    class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span
    class="kt">int</span> <span class="n">k</span><span class="p">){</span>
  <span class="cm">/* fixdown(k) num amontoado definido entre l e r */</span>
    <span class="kt">int</span> <span class="n">ileft</span><span class="p">,</span> <span class="n">iright</span><span
    class="p">,</span> <span class="n">largest</span><span class="o">=</span><span class="n">k</span><span
    class="p">;</span>

    <span class="n">ileft</span><span class="o">=</span><span class="n">l</span><span class="o">+</span><span
      class="n">left</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span
      class="n">l</span><span class="p">);</span> <span class="cm">/* filho esquerdo de k */</span>
    <span class="n">iright</span><span class="o">=</span><span class="n">l</span><span class="o">+</span><span
      class="n">right</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span
      class="n">l</span><span class="p">);</span> <span class="cm">/* filho direito de k */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ileft</span><span class="o">&lt;=</span><span
      class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="p">(</span><span
      class="n">a</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span><span
      class="n">a</span><span class="p">[</span><span class="n">ileft</span><span class="p">])){</span>
      <span class="n">largest</span><span class="o">=</span><span class="n">ileft</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iright</span><span class="o">&lt;=</span><span
      class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="p">(</span><span
      class="n">a</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span><span
      class="n">a</span><span class="p">[</span><span class="n">iright</span><span class="p">])){</span>
      <span class="n">largest</span><span class="o">=</span><span class="n">iright</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">largest</span><span class="o">!=</span><span
      class="n">k</span><span class="p">){</span>
      <span class="n">exch</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span
      class="n">k</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span
      class="n">largest</span><span class="p">]);</span>
      <span class="n">fixDown</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span
      class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span
      class="n">largest</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>


  <span class="kt">void</span> <span class="nf">buildheap</span><span class="p">(</span><span class="n">Item</span><span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span
    class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">heapsize</span> <span
      class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="n">l</span><span
      class="o">+</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span
      class="n">heapsize</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span
      class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span
      class="n">l</span><span class="p">;</span> <span class="n">k</span><span class="o">--</span><span
      class="p">){</span>
      <span class="n">fixDown</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span
      class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span
      class="n">l</span><span class="o">+</span><span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">heapsort</span><span class="p">(</span><span class="n">Item</span><span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span
    class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">){</span>

    <span class="n">buildheap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span
      class="n">l</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span
      class="p">{</span>
    <span class="n">exch</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span
      class="n">l</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span
      class="n">r</span><span class="p">]);</span>
    <span class="n">fixDown</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="o">--</span><span class="n">r</span><span class="p">,</span><span class="n">l</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Another implementation of heapSort from Geek for Geeks</span>
  <span class="c1">// More info: https://www.geeksforgeeks.org/heap-sort/</span>

  <span class="c1">// To heapify a subtree rooted with node i which is</span>
  <span class="c1">// an index in arr[]. n is size of heap</span>
  <span class="kt">void</span> <span class="nf">heapify</span><span class="p">(</span><span class="kt">int</span> <span
    class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span
    class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="p">{</span>

    <span class="kt">int</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span><span
      class="p">;</span> <span class="c1">// Initialize largest as root</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span><span
      class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span
      class="p">;</span> <span class="c1">// left = 2*i + 1</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">2</span><span
      class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span
      class="p">;</span> <span class="c1">// right = 2*i + 2</span>

    <span class="c1">// If left child is larger than root</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span
      class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span
      class="n">l</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span
      class="p">[</span><span class="n">largest</span><span class="p">])</span>
      <span class="n">largest</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>

    <span class="c1">// If right child is larger than largest so far</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span
      class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span
      class="n">r</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span
      class="p">[</span><span class="n">largest</span><span class="p">])</span>
      <span class="n">largest</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>

    <span class="c1">// If largest is not root</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">largest</span> <span class="o">!=</span> <span
      class="n">i</span><span class="p">)</span><span class="p">{</span>
      <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span
        class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span
        class="n">largest</span><span class="p">]);</span>
      <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span
        class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span
        class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span
        class="p">];</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span
        class="o">=</span> <span class="n">temp</span><span class="p">;</span>

      <span class="c1">// Recursively heapify the affected sub-tree</span>
      <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span
        class="n">n</span><span class="p">,</span> <span class="n">largest</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>


  <span class="c1">// main function to do heap sort</span>
  <span class="kt">void</span> <span class="nf">heapSort</span><span class="p">(</span><span class="kt">int</span><span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span
      class="p">){</span>
    <span class="c1">// Build heap (rearrange array)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span
      class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span
      class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span
      class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span
      class="o">--</span><span class="p">)</span>
      <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span
      class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="c1">// One by one extract an element from heap</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span
      class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span
      class="n">i</span><span class="o">--</span><span class="p">)</span><span class="p">{</span>
      <span class="c1">// Move current root to end</span>
      <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span
        class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span
        class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span
        class="p">];</span>
      <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span
        class="o">=</span> <span class="n">temp</span><span class="p">;</span>

      <span class="c1">// call max heapify on the reduced heap</span>
      <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span
        class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/*</span>
  <span class="cm">Sources: https://en.wikipedia.org/wiki/Heapsort</span>
  <span class="cm"> https://www.geeksforgeeks.org/heap-sort/</span>
  <span class="cm">*/</span></div>








  <center><h1 id = "sub2" class = "Introdução a Algoritmos e Estruturas de Dados">Insertion Sort</h1></center> <!-- increment the id for each topic ex sub1, sub2, sub3 etc  -->
            

  <div class="code code-line-numbers unselectable" id="line-numbers" aria-hidden="true">
    <span>1</span><span>2</span><span>3</span><span>4</span><span>5</span><span>6</span><span>7</span><span>8</span><span>9</span><span>10</span><span>11</span><span>12</span><span>13</span><span>14</span><span>15</span><span>16</span><span>17</span><span>18</span><span>19</span><span>20</span><span>21</span><span>22</span><span>23</span><span>24</span><span>25</span><span>26</span><span>27</span><span>28</span><span>29</span><span>30</span><span>31</span><span>32</span><span>33</span><span>34</span><span>35</span><span>36</span><span>37</span><span>38</span><span>39</span><span>40</span><span>41</span><span>42</span><span>43</span><span>44</span><span>45</span><span>46</span><span>47</span><span>48</span><span>49</span><span>50</span><span>51</span><span>52</span><span>53</span><span>54</span><span>55</span>
  </div>
  <div class="code" id="code"><span class="cm">/*</span>
  <span class="cm">Insertion sort iterates, consuming one input element each repetition,</span>
  <span class="cm">and growing a sorted output list. At each iteration, insertion sort removes</span>
  <span class="cm">one element from the input data, finds the location it belongs within the sorted</span>
  <span class="cm">list, and inserts it there. It repeats until no input elements remain.</span>


  <span class="cm">Time Complexity: O(n*2)</span>

  <span class="cm">Best case: O(n)</span>

  <span class="cm">*/</span>

  <span class="cp">#define key(A) (A)</span>
  <span class="cp">#define less(A, B) (key(A) &lt; key(B))</span>
  <span class="cp">#define exch(A, B) { int t = A; A = B; B = t; }</span>
  <span class="cp">#define compexch(A, B) if (less(B, A)) exch(A, B)</span>

  <span class="kt">int</span> <span class="nf">insertionSort</span><span class="p">(</span><span
    class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span
    class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span
    class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span
      class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span
      class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span
      class="n">i</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">;</span> <span
      class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span
      class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span
      class="mi">1</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span
      class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="p">(</span><span
      class="n">temp</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span
      class="n">j</span><span class="p">]))</span> <span class="p">{</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span
      class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span
      class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">j</span><span class="o">--</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span
      class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span
      class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="c1">// Another implementation of insertionSort from Geek for Geeks</span>
  <span class="c1">// More info: https://www.geeksforgeeks.org/insertion-sort/</span>
  <span class="kt">void</span> <span class="nf">insertionSort</span><span class="p">(</span><span
    class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span
    class="n">n</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span><span
      class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span
      class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span
      class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span
      class="p">){</span>
      <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span
        class="n">i</span><span class="p">];</span>
      <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span
        class="mi">1</span><span class="p">;</span>

      <span class="cm">/* Move elements of arr[0..i-1], that are</span>
      <span class="cm"> greater than key, to one position ahead</span>
      <span class="cm"> of their current position */</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span
        class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span
        class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span><span
        class="p">){</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span
          class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span
          class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span
          class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span
      class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span
      class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/*</span>
  <span class="cm">Sources: https://en.wikipedia.org/wiki/Shellsort</span>
  <span class="cm"> https://www.geeksforgeeks.org/shellsort</span>
  <span class="cm">*/</span></div>








      <center><h1 id="sub3" class="Introdução a Algoritmos e Estruturas de Dados">Shell Sort</h1></center>


    
      <center><h1 id="sub4" class="Introdução a Algoritmos e Estruturas de Dados">Bubble Sort</h1></center>
    

























      






      

    </div>

  </body>

</html>
