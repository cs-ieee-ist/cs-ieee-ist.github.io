<html>
  <head>
    <link rel="stylesheet" type="text/css" href="css/template.css"></link>
    <!-- template.css has all default class names -->

  </head>
  <body>

    <div id = "pageTop">
      <div id = "projectName"><center>PROJECT NAME</center></div>
      <p>

      <div id = "className"><center>Introducao aos algoritmos e estrutura de dados</center></div>

    </div>

    <div id = "pageBody">
      <!-- Page Content -->

      <center><h1 id = "sub1" class = "Introducao aos algoritmos e estrutura de dados">Heap Sort</h1></center> <!-- increment the id for each topic ex sub1, sub2, sub3 etc  -->
<div class="codewrapper">
  <p>/*</p>
  <p>In&nbsp the&nbsp first&nbsp step,&nbsp a&nbsp heap&nbsp is&nbsp built&nbsp out&nbsp of&nbsp the&nbsp data.&nbsp
    The&nbsp heap&nbsp is&nbsp often&nbsp placed</p>
  <p>&nbsp &nbsp &nbsp &nbsp in&nbsp an&nbsp array&nbsp with&nbsp the&nbsp layout&nbsp of&nbsp a&nbsp complete&nbsp
    binary&nbsp tree.</p>
  <p>In&nbsp the&nbsp second&nbsp step,&nbsp a&nbsp sorted&nbsp array&nbsp is&nbsp created&nbsp by&nbsp repeatedly&nbsp
    removing&nbsp the&nbsp largest</p>
  <p>&nbsp &nbsp &nbsp &nbsp element&nbsp from&nbsp the&nbsp heap&nbsp (the&nbsp root&nbsp of&nbsp the&nbsp heap),&nbsp
    and&nbsp inserting&nbsp it&nbsp into&nbsp the&nbsp array.</p>
  <p>&nbsp &nbsp &nbsp &nbsp The&nbsp heap&nbsp is&nbsp updated&nbsp after&nbsp each&nbsp removal&nbsp to&nbsp
    maintain&nbsp the&nbsp heap&nbsp property.</p>
  <p>&nbsp &nbsp &nbsp &nbsp Once&nbsp all&nbsp objects&nbsp have&nbsp been&nbsp removed&nbsp from&nbsp the&nbsp
    heap,&nbsp the&nbsp result&nbsp is&nbsp a&nbsp sorted&nbsp array.</p>
  <p></p>
  <p></p>
  <p>Worst&nbsp case:&nbsp O(n&nbsp log&nbsp n)</p>
  <p></p>
  <p>Best&nbsp case:&nbsp O(n&nbsp log&nbsp n)</p>
  <p></p>
  <p>*/</p>
  <p></p>
  <p></p>
  <p></p>
  <p>/*</p>
  <p></p>
  <p>Fixdown&nbsp (indice&nbsp i)</p>
  <p>&nbsp &nbsp &nbsp &nbsp verifica&nbsp se&nbsp i&nbsp tem&nbsp um&nbsp filho&nbsp maior&nbsp que&nbsp ele</p>
  <p>&nbsp &nbsp &nbsp &nbsp SE&nbsp i&nbsp tem&nbsp um&nbsp filho&nbsp maior:</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp troca&nbsp i&nbsp com&nbsp o&nbsp filho_maior</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp Fixdown&nbsp (pos_do_filho_maior)</p>
  <p></p>
  <p>*/</p>
  <p></p>
  <p>void&nbsp fixDown(Item&nbsp a[],&nbsp int&nbsp l,&nbsp int&nbsp r,&nbsp int&nbsp k){</p>
  <p>&nbsp &nbsp &nbsp &nbsp /*&nbsp fixdown(k)&nbsp num&nbsp amontoado&nbsp definido&nbsp entre&nbsp l&nbsp e&nbsp
    r&nbsp */</p>
  <p>&nbsp &nbsp &nbsp &nbsp int&nbsp ileft,&nbsp iright,&nbsp largest=k;</p>
  <p></p>
  <p>&nbsp &nbsp &nbsp &nbsp ileft=l+left(k-l);&nbsp /*&nbsp filho&nbsp esquerdo&nbsp de&nbsp k&nbsp */</p>
  <p>&nbsp &nbsp &nbsp &nbsp iright=l+right(k-l);&nbsp /*&nbsp filho&nbsp direito&nbsp de&nbsp k&nbsp */</p>
  <p></p>
  <p>&nbsp &nbsp &nbsp &nbsp if&nbsp (ileft&lt; =r&nbsp &&&nbsp less(a[largest],a[ileft])){</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp largest=ileft;</p>
  <p>&nbsp &nbsp &nbsp &nbsp }</p>
  <p>&nbsp &nbsp &nbsp &nbsp if&nbsp (iright&lt; =r&nbsp &&&nbsp less(a[largest],a[iright])){</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp largest=iright;</p>
  <p>&nbsp &nbsp &nbsp &nbsp }</p>
  <p>&nbsp &nbsp &nbsp &nbsp if&nbsp (largest!=k){</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp exch(a[k],a[largest]);</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp fixDown(a,&nbsp l,&nbsp r,&nbsp largest);</p>
  <p>&nbsp &nbsp &nbsp &nbsp }</p>
  <p>}</p>
  <p></p>
  <p></p>
  <p>void&nbsp buildheap(Item&nbsp a[],&nbsp int&nbsp l,&nbsp int&nbsp r){</p>
  <p>&nbsp &nbsp &nbsp &nbsp int&nbsp k,&nbsp heapsize&nbsp =&nbsp r-l+1;</p>
  <p></p>
  <p>&nbsp &nbsp &nbsp &nbsp for&nbsp (k&nbsp =&nbsp heapsize/2-1;&nbsp k&nbsp &gt; =&nbsp l;&nbsp k--){</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp fixDown(a,&nbsp l,&nbsp r,&nbsp l+k);</p>
  <p>&nbsp &nbsp &nbsp &nbsp }</p>
  <p>}</p>
  <p></p>
  <p>void&nbsp heapsort(Item&nbsp a[],&nbsp int&nbsp l,&nbsp int&nbsp r){</p>
  <p></p>
  <p>&nbsp &nbsp &nbsp &nbsp buildheap(a,l,r);</p>
  <p></p>
  <p>&nbsp &nbsp &nbsp &nbsp while&nbsp (r-l&nbsp &gt; &nbsp 0)&nbsp {</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp exch(a[l],&nbsp a[r]);</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp fixDown(a,&nbsp l,&nbsp --r,&nbsp l);</p>
  <p>&nbsp &nbsp &nbsp &nbsp }</p>
  <p>}</p>
  <p></p>
  <p>//&nbsp Another&nbsp implementation&nbsp of&nbsp heapSort&nbsp from&nbsp Geek&nbsp for&nbsp Geeks</p>
  <p>//&nbsp More&nbsp info:&nbsp https://www.geeksforgeeks.org/heap-sort/</p>
  <p></p>
  <p>//&nbsp To&nbsp heapify&nbsp a&nbsp subtree&nbsp rooted&nbsp with&nbsp node&nbsp i&nbsp which&nbsp is</p>
  <p>//&nbsp an&nbsp index&nbsp in&nbsp arr[].&nbsp n&nbsp is&nbsp size&nbsp of&nbsp heap</p>
  <p>void&nbsp heapify(int&nbsp arr[],&nbsp int&nbsp n,&nbsp int&nbsp i)</p>
  <p>{</p>
  <p>&nbsp &nbsp &nbsp &nbsp int&nbsp largest&nbsp =&nbsp i;&nbsp //&nbsp Initialize&nbsp largest&nbsp as&nbsp root</p>
  <p>&nbsp &nbsp &nbsp &nbsp int&nbsp l&nbsp =&nbsp 2*i&nbsp +&nbsp 1;&nbsp //&nbsp left&nbsp =&nbsp 2*i&nbsp +&nbsp 1</p>
  <p>&nbsp &nbsp &nbsp &nbsp int&nbsp r&nbsp =&nbsp 2*i&nbsp +&nbsp 2;&nbsp //&nbsp right&nbsp =&nbsp 2*i&nbsp +&nbsp 2</p>
  <p></p>
  <p>&nbsp &nbsp &nbsp &nbsp //&nbsp If&nbsp left&nbsp child&nbsp is&nbsp larger&nbsp than&nbsp root</p>
  <p>&nbsp &nbsp &nbsp &nbsp if&nbsp (l&nbsp &lt; &nbsp n&nbsp &&&nbsp arr[l]&nbsp &gt; &nbsp arr[largest])</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp largest&nbsp =&nbsp l;</p>
  <p></p>
  <p>&nbsp &nbsp &nbsp &nbsp //&nbsp If&nbsp right&nbsp child&nbsp is&nbsp larger&nbsp than&nbsp largest&nbsp so&nbsp
    far</p>
  <p>&nbsp &nbsp &nbsp &nbsp if&nbsp (r&nbsp &lt; &nbsp n&nbsp &&&nbsp arr[r]&nbsp &gt; &nbsp arr[largest])</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp largest&nbsp =&nbsp r;</p>
  <p></p>
  <p>&nbsp &nbsp &nbsp &nbsp //&nbsp If&nbsp largest&nbsp is&nbsp not&nbsp root</p>
  <p>&nbsp &nbsp &nbsp &nbsp if&nbsp (largest&nbsp !=&nbsp i)</p>
  <p>&nbsp &nbsp &nbsp &nbsp {</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp swap(arr[i],&nbsp arr[largest]);</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp int&nbsp temp&nbsp =&nbsp arr[i];</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp arr[i]&nbsp =&nbsp arr[largest];</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp arr[largest]&nbsp =&nbsp temp;</p>
  <p></p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp //&nbsp Recursively&nbsp heapify&nbsp the&nbsp affected&nbsp
    sub-tree</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp heapify(arr,&nbsp n,&nbsp largest);</p>
  <p>&nbsp &nbsp &nbsp &nbsp }</p>
  <p>}</p>
  <p></p>
  <p></p>
  <p>//&nbsp main&nbsp function&nbsp to&nbsp do&nbsp heap&nbsp sort</p>
  <p>void&nbsp heapSort(int&nbsp arr[],&nbsp int&nbsp n){</p>
  <p>&nbsp &nbsp &nbsp &nbsp //&nbsp Build&nbsp heap&nbsp (rearrange&nbsp array)</p>
  <p>&nbsp &nbsp &nbsp &nbsp for&nbsp (int&nbsp i&nbsp =&nbsp n&nbsp /&nbsp 2&nbsp -&nbsp 1;&nbsp i&nbsp &gt; =&nbsp
    0;&nbsp i--)</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp heapify(arr,&nbsp n,&nbsp i);</p>
  <p></p>
  <p>&nbsp &nbsp &nbsp &nbsp //&nbsp One&nbsp by&nbsp one&nbsp extract&nbsp an&nbsp element&nbsp from&nbsp heap</p>
  <p>&nbsp &nbsp &nbsp &nbsp for&nbsp (int&nbsp i=n-1;&nbsp i&gt; =0;&nbsp i--)</p>
  <p>&nbsp &nbsp &nbsp &nbsp {</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp //&nbsp Move&nbsp current&nbsp root&nbsp to&nbsp end</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp int&nbsp temp&nbsp =&nbsp arr[0];</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp arr[0]&nbsp =&nbsp arr[i];</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp arr[1]&nbsp =&nbsp temp;</p>
  <p></p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp //&nbsp call&nbsp max&nbsp heapify&nbsp on&nbsp the&nbsp
    reduced&nbsp heap</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp heapify(arr,&nbsp i,&nbsp 0);</p>
  <p>&nbsp &nbsp &nbsp &nbsp }</p>
  <p>}</p>
  <p></p>
  <p>/*</p>
  <p>Sources:&nbsp https://en.wikipedia.org/wiki/Heapsort</p>
  <p>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp https://www.geeksforgeeks.org/heap-sort/</p>
  <p>*/</p>
</div>
      <center><h1 id = "sub2" class = "Introducao aos algoritmos e estrutura de dados">TÃ“PICO 2</h1></center> <!-- increment the id for each topic ex sub1, sub2, sub3 etc  -->

      <!-- Code for Topic 2 goes here -->
      ADD STUFF TO ME

      <!-- Page Content -->
    </div>

  </body>

</html>
